/**
 * Credential Collection
 *
 * Interactive prompts to collect all required API credentials.
 * Saves to .env as credentials are validated, so setup can resume if interrupted.
 */

import { readFileSync, writeFileSync, existsSync } from "fs";
import { input, password, select, confirm } from "@inquirer/prompts";
import { ui } from "./ui.js";
import { verifyBotToken } from "./webhook.js";
import { verifyGitHubToken } from "./github.js";

export interface Credentials {
  telegram: {
    botToken: string;
    chatId: string;
  };
  anthropic: {
    apiKey: string;
  };
  github: {
    token: string;
  };
  gemini?: {
    apiKey: string;
  };
  timezone: string;
}

const ENV_FILE = ".env";

/**
 * Load existing .env file into a map
 */
function loadEnvFile(): Map<string, string> {
  const env = new Map<string, string>();
  if (!existsSync(ENV_FILE)) return env;

  const content = readFileSync(ENV_FILE, "utf-8");
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex === -1) continue;
    const key = trimmed.slice(0, eqIndex);
    let value = trimmed.slice(eqIndex + 1);
    // Remove quotes if present
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }
    env.set(key, value);
  }
  return env;
}

/**
 * Save a key-value pair to .env file
 */
function saveToEnv(key: string, value: string): void {
  const env = loadEnvFile();
  env.set(key, value);

  const lines: string[] = ["# IronClaude Configuration", "# Generated by npm run setup", ""];
  for (const [k, v] of env) {
    // Quote values that contain spaces or special chars
    const needsQuotes = /[\s#]/.test(v);
    lines.push(`${k}=${needsQuotes ? `"${v}"` : v}`);
  }
  writeFileSync(ENV_FILE, lines.join("\n") + "\n");
}

/**
 * Verify Anthropic API key by making a test request
 */
async function verifyAnthropicKey(apiKey: string): Promise<void> {
  const response = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "x-api-key": apiKey,
      "anthropic-version": "2023-06-01",
      "content-type": "application/json",
    },
    body: JSON.stringify({
      model: "claude-3-haiku-20240307",
      max_tokens: 1,
      messages: [{ role: "user", content: "hi" }],
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    if (error.includes("invalid x-api-key") || error.includes("Invalid API Key")) {
      throw new Error("Invalid Anthropic API key");
    }
    // Other errors (rate limit, etc.) mean the key is valid
    if (response.status === 429 || response.status >= 500) {
      return; // Key is valid, just rate limited or server error
    }
    throw new Error(`Anthropic API error: ${error}`);
  }
}

/**
 * Verify Gemini API key
 */
async function verifyGeminiKey(apiKey: string): Promise<void> {
  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`
  );
  if (!response.ok) {
    throw new Error("Invalid Gemini API key");
  }
}

/**
 * Collect all required credentials from user
 * Loads from .env if available and validates existing credentials
 */
export async function collectCredentials(): Promise<Credentials> {
  ui.step(1, 5, "Credentials");

  const env = loadEnvFile();

  // --- Telegram Bot Token ---
  let botToken = env.get("TELEGRAM_BOT_TOKEN") || "";
  let botUsername = "";

  if (botToken) {
    const spinner = ui.spinner("Verifying saved Telegram bot token...");
    try {
      botUsername = await verifyBotToken(botToken);
      spinner.success({ text: `Telegram bot verified: @${botUsername}` });
    } catch {
      spinner.error({ text: "Saved Telegram token is invalid" });
      botToken = "";
    }
  }

  if (!botToken) {
    ui.info("Let's connect your Telegram bot.");
    ui.info("Create one at https://t.me/botfather");
    ui.blank();

    while (!botToken) {
      const token = await password({
        message: "Telegram Bot Token:",
        validate: (v) => {
          if (!v) return "Token is required";
          if (!v.includes(":")) return 'Invalid token format (should contain ":")';
          return true;
        },
      });

      const spinner = ui.spinner("Verifying...");
      try {
        botUsername = await verifyBotToken(token);
        spinner.success({ text: `Bot verified: @${botUsername}` });
        botToken = token;
        saveToEnv("TELEGRAM_BOT_TOKEN", botToken);
      } catch {
        spinner.error({ text: "Invalid token. Please try again." });
      }
    }
  }

  // --- Telegram Chat ID ---
  let chatId = env.get("TELEGRAM_CHAT_ID") || "";

  if (!chatId) {
    ui.blank();
    ui.info("To get your Chat ID:");
    ui.info("1. Send any message to your bot on Telegram");
    ui.info('2. Visit the URL below and look for "chat":{"id":XXXXX}');
    ui.info(`   https://api.telegram.org/bot${botToken}/getUpdates`);
    ui.blank();

    chatId = await input({
      message: "Your Chat ID:",
      validate: (v) => {
        if (!v) return "Chat ID is required";
        if (!/^-?\d+$/.test(v)) return "Chat ID must be a number";
        return true;
      },
    });
    saveToEnv("TELEGRAM_CHAT_ID", chatId);
  } else {
    ui.success(`Using saved Chat ID: ${chatId}`);
  }

  // --- Anthropic API Key ---
  let anthropicKey = env.get("ANTHROPIC_API_KEY") || "";

  if (anthropicKey) {
    const spinner = ui.spinner("Verifying saved Anthropic API key...");
    try {
      await verifyAnthropicKey(anthropicKey);
      spinner.success({ text: "Anthropic API key verified" });
    } catch {
      spinner.error({ text: "Saved Anthropic key is invalid" });
      anthropicKey = "";
    }
  }

  if (!anthropicKey) {
    ui.blank();
    ui.info("Now let's connect to Claude.");
    ui.info("Get your API key at https://console.anthropic.com");
    ui.blank();

    while (!anthropicKey) {
      const key = await password({
        message: "Anthropic API Key:",
        validate: (v) => {
          if (!v) return "API key is required";
          if (!v.startsWith("sk-ant-")) return 'Should start with "sk-ant-"';
          return true;
        },
      });

      const spinner = ui.spinner("Verifying...");
      try {
        await verifyAnthropicKey(key);
        spinner.success({ text: "Anthropic API key verified" });
        anthropicKey = key;
        saveToEnv("ANTHROPIC_API_KEY", anthropicKey);
      } catch {
        spinner.error({ text: "Invalid API key. Please try again." });
      }
    }
  }

  // --- GitHub Token ---
  let githubToken = env.get("GITHUB_TOKEN") || "";
  let githubUsername = "";

  if (githubToken) {
    const spinner = ui.spinner("Verifying saved GitHub token...");
    try {
      githubUsername = await verifyGitHubToken(githubToken);
      spinner.success({ text: `GitHub verified: ${githubUsername}` });
    } catch {
      spinner.error({ text: "Saved GitHub token is invalid" });
      githubToken = "";
    }
  }

  if (!githubToken) {
    ui.blank();
    ui.info("Your fitness data will be stored in a private GitHub repo.");
    ui.info("Create a fine-grained token at https://github.com/settings/tokens?type=beta");
    ui.info("Required permissions: Contents (read/write), Metadata (read)");
    ui.blank();

    while (!githubToken) {
      const token = await password({
        message: "GitHub Token:",
        validate: (v) => {
          if (!v) return "Token is required";
          if (v.length < 20) return "Token seems too short";
          return true;
        },
      });

      const spinner = ui.spinner("Verifying...");
      try {
        githubUsername = await verifyGitHubToken(token);
        spinner.success({ text: `GitHub verified: ${githubUsername}` });
        githubToken = token;
        saveToEnv("GITHUB_TOKEN", githubToken);
      } catch {
        spinner.error({ text: "Invalid token. Please try again." });
      }
    }
  }

  // --- Voice Transcription (optional) ---
  let geminiKey = env.get("GEMINI_API_KEY") || "";

  if (geminiKey) {
    const spinner = ui.spinner("Verifying saved Gemini API key...");
    try {
      await verifyGeminiKey(geminiKey);
      spinner.success({ text: "Gemini API key verified (voice enabled)" });
    } catch {
      spinner.error({ text: "Saved Gemini key is invalid" });
      geminiKey = "";
    }
  }

  if (!geminiKey) {
    ui.blank();
    const wantVoice = await confirm({
      message: "Enable voice messages? (requires Gemini API key)",
      default: false,
    });

    if (wantVoice) {
      ui.info("Get your API key at https://aistudio.google.com/apikey");
      ui.info("Gemini has a generous free tier for voice transcription.");

      while (!geminiKey) {
        const key = await password({ message: "Gemini API Key:" });
        if (!key) {
          ui.warn("Skipping voice messages.");
          break;
        }

        const spinner = ui.spinner("Verifying...");
        try {
          await verifyGeminiKey(key);
          spinner.success({ text: "Gemini API key verified" });
          geminiKey = key;
          saveToEnv("GEMINI_API_KEY", geminiKey);
        } catch {
          spinner.error({ text: "Invalid API key. Please try again or press Enter to skip." });
        }
      }
    }
  }

  // --- Timezone ---
  let timezone = env.get("TIMEZONE") || "";

  if (!timezone) {
    ui.blank();
    timezone = await select({
      message: "Your timezone:",
      choices: [
        { value: "America/New_York", name: "Eastern (NYC, Miami)" },
        { value: "America/Chicago", name: "Central (Chicago, Houston)" },
        { value: "America/Denver", name: "Mountain (Denver, Phoenix)" },
        { value: "America/Los_Angeles", name: "Pacific (LA, Seattle)" },
        { value: "Europe/London", name: "London" },
        { value: "Europe/Paris", name: "Paris / Berlin / Amsterdam" },
        { value: "Europe/Moscow", name: "Moscow" },
        { value: "Asia/Dubai", name: "Dubai" },
        { value: "Asia/Singapore", name: "Singapore" },
        { value: "Asia/Tokyo", name: "Tokyo" },
        { value: "Australia/Sydney", name: "Sydney" },
        { value: "other", name: "Other..." },
      ],
    });

    if (timezone === "other") {
      timezone = await input({
        message: "Enter IANA timezone (e.g., Australia/Melbourne):",
        validate: (v) => (v ? true : "Timezone is required"),
      });
    }
    saveToEnv("TIMEZONE", timezone);
  } else {
    ui.success(`Using saved timezone: ${timezone}`);
  }

  ui.blank();
  ui.success("All credentials verified and saved to .env");

  return {
    telegram: { botToken, chatId },
    anthropic: { apiKey: anthropicKey },
    github: { token: githubToken },
    gemini: geminiKey ? { apiKey: geminiKey } : undefined,
    timezone,
  };
}
